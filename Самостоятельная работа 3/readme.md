## Самостоятельная работа №3

**Тема**: Реляционная модель данных: допустимые структуры, ограничения и операции реляционной алгебры

---

### Задание 3.1. Реализация реляционной модели данных

#### Определение потенциальных и первичных ключей:

| Таблица   | Потенциальные ключи     | Первичный ключ          | Альтернативные ключи |
| --------- | ----------------------- | ----------------------- | -------------------- |
| Игра      | Производитель, Название | Производитель, Название | -                    |
| Клиент    | Ид\_клиента, Почта      | Ид\_клиента             | Почта                |
| Заказ     | Номер                   | Номер                   | -                    |
| Сотрудник | Таб. Номер              | Таб. Номер              | -                    |

> **Примечание**: Почта клиента указана как альтернативный ключ, но она не обязательна при регистрации, поэтому может содержать NULL.

---

#### Обязательные атрибуты (NOT NULL):

| Таблица   | Обязательные атрибуты                                |
| --------- | ---------------------------------------------------- |
| Игра      | Производитель, Название, Мин\_игроков, Макс\_игроков |
| Клиент    | Ид\_клиента, Фамилия, Имя, Почта                     |
| Заказ     | Номер, Получение, Создан                             |
| Сотрудник | Таб. Номер, Фамилия, Имя                             |

---

#### Условия проверки значений (CHECK / логические выражения):

**Для клиента (Client):**

```sql
mail LIKE '%@%.%'
date_of_birth < CURRENT_DATE
phone_number LIKE '+7__________' OR phone_number LIKE '8__________'
```

**Для игры (Game):**

```sql
min_players >= 1 AND min_players <= max_players
max_players > 0
min_age >= 0
```

**Для заказа (Order):**

```sql
получение IN ('Самовывоз', 'Доставка')
создан < CURRENT_TIMESTAMP
```

> Некоторые проверки можно опустить, если используется тип `ENUM`, `UNSIGNED`, `TIMESTAMP DEFAULT CURRENT_TIMESTAMP` и т.д.

---

#### Связи между отношениями

Связи реализуются через внешние ключи (FK), добавляя в дочернюю таблицу ключ главной:

| Связь                | FK в дочерней таблице | Поведение при изменении / удалении         |
| -------------------- | --------------------- | ------------------------------------------ |
| Клиент → Заказ       | client\_id            | `ON DELETE RESTRICT`, `ON UPDATE RESTRICT` |
| Сотрудник → Заказ    | employee\_id          | `ON DELETE RESTRICT`, `ON UPDATE CASCADE`  |
| Заказ → order\_item  | order\_id             | `ON DELETE CASCADE`, `ON UPDATE CASCADE`   |
| Игра → order\_item   | game\_name            | `ON DELETE RESTRICT`, `ON UPDATE CASCADE`  |
| Производитель → Игра | game\_manufacturer    | `ON DELETE CASCADE`, `ON UPDATE CASCADE`   |

---

#### Поддержка связи один-к-одному (1:1) между заказом и сотрудником

Если по условию каждый сотрудник может обработать **только один заказ**, необходимо:

* В таблице `Order` сделать поле `employee_id` **уникальным**:

  ```sql
  UNIQUE (employee_id)
  ```
* Обновить внешний ключ:

  ```sql
  FOREIGN KEY (employee_id) REFERENCES Employee(id)
  ON DELETE CASCADE
  ON UPDATE CASCADE
  ```

**Что это даст:**

* Один сотрудник не может быть указан в нескольких заказах
* При удалении сотрудника — заказ тоже удаляется (если логика этого требует)
* Нарушения уникальности предотвратятся на уровне БД (ошибка при вставке дубликатов)

---

### Задание 3.2. Выделение сущностей и связей

На основе предметной области определены следующие сущности и связи:

#### Сущности:

* Клиент (Client)
* Сотрудник (Employee)
* Заказ (Order)
* Игра (Game)
* Элемент заказа (Order\_Item)
* Производитель (Manufacturer)

#### Связи:

1. **Client → Order**

   * Поле: `client_id`
   * `ON DELETE RESTRICT`, `ON UPDATE RESTRICT`

2. **Employee → Order**

   * Поле: `employee_id`
   * `ON DELETE RESTRICT`, `ON UPDATE CASCADE`

3. **Order → Order\_Item**

   * Поле: `order_id`
   * `ON DELETE CASCADE`, `ON UPDATE CASCADE`

4. **Game → Order\_Item**

   * Поле: `game_name`
   * `ON DELETE RESTRICT`, `ON UPDATE CASCADE`

5. **Manufacturer → Game**

   * Поле: `game_manufacturer`
   * `ON DELETE CASCADE`, `ON UPDATE CASCADE`

---

> **Обоснование связей**:

* Удаление клиента/сотрудника невозможно, если на него ссылаются заказы.
* При удалении заказа автоматически удаляются все его элементы.
* При удалении игры — удаление запрещено, если она в заказе.
* При удалении производителя — все его игры удаляются (логично, если производитель уходит с рынка).

---

### Вывод:

В работе реализована реляционная модель с учетом:

* первичных и альтернативных ключей,
* обязательных атрибутов,
* логических ограничений,
* корректных связей между таблицами.
